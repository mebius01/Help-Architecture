# SOLID

> При создании программных систем использование принципов SOLID способствует созданию такой системы, 
> которую будет легко поддерживать и расширять в течение долгого времени. 
> Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения, например, для удаления «дурно пахнущего кода».

---

[S: Single Responsibility Principle](./srp.md)  
> Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, 
> его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. 
> Изменения в одной такой подсистеме ведут к изменениям в другой.

[O: Open-Closed Principle](./ocp.md)  
> Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

[L: Liskov Substitution Principle](./lsp.md)  
> поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода, использующего переменную базового типа.
>
> Наследуемый класс должен дополнять, а не замещать поведение базового класса

[I: Interface Segregation Principle](./isp.md)  
> Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие
> и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе.
> В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.
>  
> Нельзя заставлять функцию, объект, класс реализовывать интерфейс которым он не использует 
[D: Dependency Inversion Principle](./dip.md)  
> Объектом зависимости должна быть абстракция, а не что-то конкретное.
> 
> Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
> Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

---


[Home](../README.md)